'''
We formulated the problem as tree search algorithm. Root of the tree is the board given as input. From this input
configuration successor boards are generated by placing a pebble in an empty cell. This process is continued for each
branch until a terminal state is reached, or given time is elapsed. In the second case a evaluation function is used
find out how favorable the state for max is. Our evaluation function returns:

sum_of(row,col,diag with odd number of empty spaces)-sum_of(row,col,diag) with even number of empty spaces).

The idea is that, after Max makes the move, the more row/col/diagonal with odd number of filled slots the better. For
example, if all the rows are left with only one empty slot, then Min must fill one row in the next move. If there are
3 such slots, then Min will take one, then Max will take the second last one, and then finally Min will again fill the
row. Alternatively, leaving more rows/cols/diagonal with even number of empty slots will help Min to win.


So our algorithm starts with the given board, searches the tree using iterative deepening. It starts with depth=1 and
then increases depth until given time is not spent. Also it computes maximum depth possible for a given configuration
so that it can return after that depth even if time is available. The transportation table is used for move ordering
so that alpha beta pruning actually can prune unnecessary branches.
'''

import Queue
import random
import math
import sys
import copy
import Queue
import time
import sys

call_count = 0
transposition_table = {}  # save moves from previous iteration of Iterative Deepening
max_depth_possible = 0
depth_limit = 1
time_spent = 0
time_allocated = 0
start_time = 0


def terminal_test(board):
    num_rows = int(math.sqrt(len(board)))
    num_cols = num_rows

    for i in xrange(num_rows):
        row_empty = 0
        for j in xrange(num_cols):
            if board[i * num_rows + j] == '.':
                row_empty += 1
        if row_empty == 0:
            return True

    for j in xrange(num_cols):
        col_empty = 0
        for i in xrange(num_rows):
            if board[i * num_rows + j] == '.':
                col_empty += 1
        if col_empty == 0:
            return True

    diag1_empty = 0
    diag2_empty = 0
    for i in xrange(num_rows):
        if board[i * num_rows + i] == '.':
            diag1_empty += 1
        if board[i * num_rows + num_rows - 1 - i] == '.':
            diag2_empty += 1
    if diag1_empty == 0 or diag2_empty == 0:
        return True

    return False


def get_next_states(board):
    next_states = []
    for i in xrange(len(board)):
        if board[i] == '.':
            next_states.append(board[:i] + 'x' + board[i + 1:])
    return next_states


def utility(board, max_turn):
    if terminal_test(board):
        return 999 if max_turn else -999
    num_rows = int(math.sqrt(len(board)))
    num_cols = num_rows

    row_empties = []
    for i in xrange(num_rows):
        row_empty = 0
        for j in xrange(num_cols):
            if board[i * num_rows + j] == '.':
                row_empty += 1
        row_empties.append(row_empty)

    col_empties = []
    for j in xrange(num_cols):
        col_empty = 0
        for i in xrange(num_rows):
            if board[i * num_rows + j] == '.':
                col_empty += 1
        col_empties.append(col_empty)

    diag1_empty = 0
    diag2_empty = 0
    for i in xrange(num_rows):
        if board[i * num_rows + i] == '.':
            diag1_empty += 1
        if board[i * num_rows + num_rows - 1 - i] == '.':
            diag2_empty += 1

    odds = int(math.fmod(diag1_empty, 2) + math.fmod(diag2_empty, 2))
    for i in xrange(num_rows):
        odds += int(math.fmod(row_empties[i], 2) + math.fmod(col_empties[i], 2))
    evens = 2 * num_rows + 2 - odds
    return odds - evens


def max_min_val(board, alpha, beta, depth, max_turn):
    global call_count, transposition_table, depth_limit, time_allocated, start_time
    call_count += 1
    if terminal_test(board) or (time.time() - start_time) >= time_allocated or depth >= depth_limit:
        return utility(board, max_turn)
    if max_turn:
        v = -999
    else:
        v = 999
    depth += 1
    if depth not in transposition_table:
        transposition_table[depth] = {}
    if board not in transposition_table[depth]:
        transposition_table[depth][board] = {}

    if transposition_table[depth][board]:
        next_states = transposition_table[depth][board].items()
        next_states = sorted(next_states, key=lambda x: x[1],
                             reverse=True)  # order the moves according to evaluation values
        next_states = [i[0] for i in next_states]
        transposition_table[depth][board].clear()

    else:
        next_states = get_next_states(board)
    for next_state in next_states:
        if next_state in transposition_table[depth][board]:
            ret = transposition_table[depth][board][next_state]
        else:
            ret = max_min_val(next_state, alpha, beta, depth, not max_turn)
            transposition_table[depth][board][next_state] = ret

        if max_turn:
            v = max(v, ret)
            if v >= beta:
                return v
            alpha = max(alpha, v)
        else:
            v = min(v, ret)
            if v <= alpha:
                return v
            beta = min(beta, v)
    return v


def alpha_beta_search(board, t):
    global call_count, transposition_table, depth_limit, max_depth_possible, time_allocated, start_time
    call_count = 0

    start_time = time.time()
    time_allocated = t - .02

    transposition_table.clear()
    alpha = -999
    beta = 999
    max_depth_possible = 0
    call_count = 0
    depth_limit = 1

    if terminal_test(board):
        return board, 0
    else:
        max_depth_possible = len(get_next_states(board))

    while (time.time() - start_time) < time_allocated:
        max_min_val(board, alpha, beta, 0, True)
        if depth_limit >= max_depth_possible:
            break
        depth_limit += 1

    moves = []
    if 1 in transposition_table and board in transposition_table[1] and transposition_table[1][board]:
        moves = list(transposition_table[1][board].items())
        moves.sort(key=lambda tup: tup[1])

    return moves[len(moves) - 1][0], call_count


board = sys.argv[2]
t = float(sys.argv[3])
board, cost = alpha_beta_search(board, t)
print board
